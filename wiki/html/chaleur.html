<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Propagation de la chaleur - Sujets des TDs du cours de programmation parallèle et réactive</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Sujets de TDs pour le cours de M1 sur la programmation parallèle et réactive à l'ENS">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./td_1.html"><strong>1.</strong> TD 1 - Parallelisme de données</a></li><li><ul class="section"><li><a href="./prise_en_main.html"><strong>1.1.</strong> Prise en main de Rust</a></li><li><a href="./chaleur.html" class="active"><strong>1.2.</strong> Propagation de la chaleur</a></li></ul></li><li><a href="./ressources.html"><strong>2.</strong> Ressources utiles</a></li><li><ul class="section"><li><a href="benchmark.html"><strong>2.1.</strong> Benchmark de code Rust</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Sujets des TDs du cours de programmation parallèle et réactive</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./chaleur.html#simulation-de-la-propagation-de-la-chaleur" id="simulation-de-la-propagation-de-la-chaleur"><h1>Simulation de la propagation de la chaleur</h1></a>
<p>Le but de cet exercice est de simuler la propagation de la chaleur dans un matériau
uniforme, en deux dimensions. Pour cela, on commencera par écrire une version séquentielle
du calcul avant de le paralléliser.</p>
<a class="header" href="./chaleur.html#affichage-de-la-carte-de-temperature" id="affichage-de-la-carte-de-temperature"><h2>Affichage de la carte de temperature</h2></a>
<p>La première étape est de créer un projet qui affiche un image dans un fenêtre. Pour cela,
nous utiliserons les bibliothèques:</p>
<ul>
<li><a href="https://crates.io/crates/piston_window">piston_window</a> pour afficher une fenêtre graphique,</li>
<li><a href="https://crates.io/crates/image">image</a> pour créer un image à partir de la distribution de la température,
et</li>
<li><a href="https://crates.is/crates/fps_counter">fps_counter</a> pour compter le nombre d'images produites par seconde.</li>
</ul>
<p>Créez un nouveau projet Rust (<code>cargo init --bin</code>) et éditez la section <code>[dependencies]</code> du
ficher <code>Cargo.toml</code> pour dépendre de ces libraires.</p>
<pre><code class="language-toml">[dependencies]
fps_counter = &quot;1.0&quot;
image = &quot;0.15&quot;
piston_window = &quot;0.70&quot;
</code></pre>
<p>On donne une fonction <code>display</code> qui affiche une image dans une fenêtre. Cette fonction
prend en argument le titre de la fenêtre, sa largeur et sa hauteur ainsi qu'une fonction
<code>step</code> calculant un pas de la simulation. La fonction <code>step</code> prend en argument une
référence mutable vers l'image afficher dans la fenêtre et est chargée de la mettre à
jours pour le pas suivant.</p>
<pre><pre class="playpen"><code class="language-rust">//! Simulation de l'équation de la chaleur.
extern crate fps_counter;
extern crate image;
extern crate piston_window;

use piston_window::*;

/// Ouvre une fenêtre pour afficher une image. L'image est mise à jour entre chaque
/// affichage en appelant la fonction `step`.
pub fn display&lt;F&gt;(title: &amp;str, height: usize, width: usize, mut step: F)
        where F: FnMut(&amp;mut image::RgbaImage) {
    // Création de la fenêtre.
    let glutin_window = WindowSettings::new(title, (width as u32, height as u32))
        .exit_on_esc(true)
        .resizable(false)
        .srgb(false) // Necessary due to issue #139 of piston_window.
        .build()
        .unwrap_or_else(|e| panic!(&quot;Failed to build window: {}&quot;, e));
    let mut window: PistonWindow = PistonWindow::new(OpenGL::V3_2, 0, glutin_window);
    // Création de l'image.
    let black_pixel = image::Rgba { data: [0, 0, 0, 255] };
    let mut img = image::RgbaImage::from_pixel(width as u32, height as u32, black_pixel);
    let tex_settings = TextureSettings::new();
    let mut tex_factory = window.factory.clone();
    // Création du conteur de FPS.
    let mut fps_counter = fps_counter::FPSCounter::new();
    let font = &quot;assets/FiraMono-Regular.ttf&quot;;
    let glyph_settings = TextureSettings::new();
    let mut glyphs = Glyphs::new(font, window.factory.clone(), glyph_settings).unwrap();

    // Boucle de traitement des évenements.
    while let Some(e) = window.next() {
        window.draw_2d(&amp;e, |c, g| {
            clear([0.0, 0.0, 0.0, 1.0], g);
            // Affichage d'un pas de calcul.
            step(&amp;mut img);
            let tex = Texture::from_image(&amp;mut tex_factory, &amp;img, &amp;tex_settings).unwrap();
            image(&amp;tex, c.transform, g);
            // Affichage du compteur de fps.
            let fps = format!(&quot;{} fps&quot;, fps_counter.tick());
            let transform = c.transform.trans((width-100) as f64, 30.0);
            text([1.0, 1.0, 1.0, 1.0], 32, &amp;fps, &amp;mut glyphs, transform, g);
        });
        e.idle(|_| {
            fps_counter.tick();
            step(&amp;mut img);
        });
    }
}

/// Hauteur de la carte de température.
const HEIGHT: usize = 600;
// Largeur de la carte de température.
const WIDTH: usize = 800;

fn main() {
    display(&quot;Propagation de la chaleur 2D&quot;, HEIGHT, WIDTH, |image| {
      // TODO: calculer un pas de simulation
    });
}
</code></pre></pre>
<p>Pour pouvoir afficher le nombre d'image par seconde, nous avons besoin de fournir une
police de caractères. Pour cela, créez un dossier <code>assets/</code> à la racine du projet et
copiez y le fichier de police <a href="https://github.com/mozilla/Fira/raw/master/ttf/FiraMono-Regular.ttf">Fira Mono</a> (<a href="https://raw.githubusercontent.com/mozilla/Fira/master/LICENSE">license</a>).</p>
<p>Si vous compiler et exécutez le code, vous devriez maintenant voir une fenêtre noire avec
un compteur d'image par seconde en haut à droite s'afficher. Le deuxième étape est
maintenant de mettre à jours l'image avec la valeur de la température. La température est
stockée dans un tableau de tableau de flotants (type <code>Vec&lt;Vec&lt;f64&gt;&gt;</code>). Afin de convertir
la température en couleur, nous fournissons la fonctions <code>map_color</code> qui convertie un
flotant entre -1 et 1 en composantes rouge, verte et bleue.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Maps values between -1 and 1 to RGB colors.
fn map_color(value: f64) -&gt; (u8, u8, u8) {
    // Express as HSL with S=1 and L=.5, and H between 0(red) and 4/6(blue).
    let h = f64::max(0.0, f64::min(1.0, (1.0-value) * 2.0/6.0));
    // Then convert to RGB.
    let x = 1.0 - (((h*6.0) % 2.0) - 1.0).abs();
    let (r, g, b) = if h &lt; 1.0/6.0 {
        (1.0, x, 0.0)
    } else if h &lt; 2.0/6.0 {
        (x, 1.0, 0.0)
    } else if h &lt; 3.0/6.0 {
        (0.0, 1.0, x)
    } else {
        (0.0, x, 1.0)
    };
    ((r*255.0) as u8, (g*255.0) as u8 , (b*255.0) as u8)
}
#}</code></pre></pre>
<p><strong>Question 1.</strong> Écrivez une fonction <code>temp_to_image</code> qui prend en entrée une référence
vers la matrice de température et une référence mutable vers l'image et qui modifie
l'image pour représenter la température. L'image est représentée comme un tableau de bytes
(type <code>[u8]</code>) de taille <code>4*HEIGHT*WIDTH</code> où:</p>
<ul>
<li>la case <code>4 * (i * WIDTH + j)</code> représente la composante rouge du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 1</code> représente la composante verte du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 2</code> représente la composante bleue du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 3</code> représente la composante transparence du pixel (i, j),
à laisser à 255 (opaque) dans notre cas.</li>
</ul>
<p><strong>Question 2.</strong> Pour vérifier que tout marche, on va maintenant afficher la distribution
de température \(u(x, y, t)\):</p>
<p>\[u(x, y, t) = \sin \left( \frac{t+x+y}{2\pi} \right)\]</p>
<p>Modifiez la fonction <code>main</code> pour afficher cette distribution en utilisant la fonction
<code>temp_to_image</code>. Vous utiliserez les constantes <code>DT</code> et <code>DX</code> définies comme suit pour
représenter le pas temporel de calcul et l'espacement entre deux pixels. La constante
\(\pi\) est définie en Rust par <code>std::f64::consts::PI</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Pas temporel de calcul.
const DT: f64 = 1.0e-2;
/// Pas dimentionel de calcul.
const DX: f64 = 1.0e-1;
#}</code></pre></pre>
<p>Vous devriez obtenir une image avec des bandes transversales qui se déplacent, comme dans
l'image ci-dessous.</p>
<p><img src="img/heat_wave.jpg" alt="Vagues de chaleur" /></p>
<a class="header" href="./chaleur.html#calcul-séquentiel" id="calcul-séquentiel"><h2>Calcul séquentiel</h2></a>
<p>On va maintenant passer à la simulation de la diffusion de la chaleur. La propagation de
la chaleur est définie par l'équation:
\[\frac{\partial u}{\partial t} =
K \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right)
\]
Ce qui donne, une fois discrétisé:
\[
\begin{eqnarray}
u(t+dt, x, y) = u(t, x, y) + \frac{K \times dt}{dx^2} &amp;\Big[&amp; u(t, x-dx, y) + u(t, x+dx, y) - 2 u(t, x, y) \\
&amp;+&amp; u(t, x, y-dx) + u(t, x, y+dx) - 2 u(t, x, y) \Big]
\end{eqnarray}
\]</p>
<p><strong>Question 3.</strong> Écrire une fonction <code>small_step</code> qui calcule la nouvelle carte de
température en fonction de l'ancienne. La constante <code>K</code> sera pour le moment fixée à 25.
On réutilisera la distribution de la question 2 pour la valeur de la température aux
bords.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const K: f64 = 25.0;

fn small_step(old_temp: &amp;Vec&lt;Vec&lt;f64&gt;&gt;, new_temp: &amp;mut Vec&lt;Vec&lt;f64&gt;&gt;, time: f64) {
    // TODO: calculer new_temp en fonction de old_temp
}
#}</code></pre></pre>
<p>On ne peux pas afficher la carte de température à chaque pas de calcul car cela
consommerait trop de ressources. À la place, on fait plusieurs appels à <code>small_step</code> dans
chaque appel de la fonction <code>step</code> passé à display. Le nombre de petits pas de calcul
sera défini par la constante <code>SMALL_STEP</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const SMALL_STEP: usize = 32;
#}</code></pre></pre>
<p><strong>Question 4.</strong> Modifier la fonction <code>main</code> pour simuler l'équation de la chaleur. On
initialisera la carte de température à <code>-1</code>. Pour échanger les valeurs de l'ancienne de la
nouvelle carte de température, vous pourrez utiliser la fonction
<a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>std::mem::swap</code></a></p>
<p>Il est conseillé de fixer <code>DT</code> à \(10^{-4}\) pour que le pas temporel ne soit pas trop
grand et que la simulation fonctionne. Vous pourrez ensuite jouer avec les différents
paramètre pour voire comment évolue la distribution de la chaleur.</p>
<p>Attention, si vous voulez tester la rapidité de votre code, il faut passer l'option
<code>--release</code> à Cargo. En effet, sans cette option, le code généré sera beaucoup moins
optimisé et donc anormalement lent.</p>
<a class="header" href="./chaleur.html#parallélisation-du-code" id="parallélisation-du-code"><h2>Parallélisation du code</h2></a>
<p>On va maintenant paralléliser les fonctions <code>small_step</code> et <code>temp_to_image</code> afin
d'accélérer la simulation. Pour cela, nous utiliserons la bibliothèque <a href="https://crates.io/crates/rayon">rayon</a>i
vue en cours.  Il faut donc ajouter une dépendance à la version <code>0.8</code> de rayon dans le
fichier <code>Cargo.toml</code>. Nous vous invitons fortement à consulter la
<a href="https://docs.rs/rayon/">documentation</a> de rayon et notamment les pages sur les traits
<a href="https://docs.rs/rayon/0.8.2/rayon/iter/trait.ParallelIterator.html">ParallelIterator</a> et <a href="https://docs.rs/rayon/0.8.2/rayon/iter/trait.IndexedParallelIterator.html">IndexedParallelIterator</a>
qui indiquent les opérations que l'on peux effectuer sur un itérateur parallèle et sur un
itérateur parallèle indéxé. On rappelle que pour utiliser rayon, il faut importer le
prélude de rayon dans le contexte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rayon::prelude::*;
#}</code></pre></pre>
<p><strong>Question 5.</strong> Écrivez un version parallèle de <code>small_step</code> que vous nommerez
<code>small_step_par</code> et modifiez la fonction <code>main</code> pour l'utiliser. Vérifiez que vous
améliorez bien la vitesse de simulation.</p>
<p><strong>Question 6.</strong> De même, parallélisez la fonction <code>temp_to_image</code>.</p>
<p>On veux maintenant mesurer de façon précise le gain de performance apporté par le
parallélisme. Pour cela, on va benchmarker la fonction <code>small_step</code> en isolation.
Pour mesurer le temps d'exécution, on utilisera les fonctionnalités de benchmarking de
Rust décrites <a href="benchmark.html">ici</a>.</p>
<p><strong>Question 7.</strong> Calculez le facteur d'accélération des versions parallèles de
<code>small_step</code> et de <code>temp_to_image</code> par rapport aux versions séquentielles.</p>
<p><strong>Question 8 (exploratoire).</strong> On souhaite à présent optimiser la fonction <code>small_step</code> afin
d'accélérer encore la simulation.</p>
<ol>
<li>
<p>La première idée consiste à tirer parti de la localité temporelle du calcul, en effectuant un <em>déroulage de boucle</em> selon la deuxième dimension. Le compilateur pourra ainsi découvrir automatiquement que les valeurs lues sur le front droit du stencil viennent d'être calculées quelques instructions plus tôt, et éliminera ainsi quelques accès mémoire.</p>
</li>
<li>
<p>Une autre approche repose sur la <em>vectorisation</em> des instructions de calcul à travers plusieurs itérations de la première dimension. Le compilateur Rust reposant sur LLVM (http://llvm.org), un environnement très riche de compilation disposant d'une passe de vectorisation automatique, capable de regrouper plusieurs opérations ou accès mémoire consécutifs en une seule instruction dite <em>vectorielle</em> (ou <em>SIMD</em>) du processeur. On pourra tenter de déclencher cette vectorisation au prix d'une transformation de boucles appelée <em>stripmining</em>, effectuant le calcul par pas d'exactement 4 itérations (les instructions vectorielles sur processeurs x86 sont de taille 256 bits, soit 4 nombres à virgule flottante de 64 bits sur la plupart des processeurs récents). La configuration fine du compilateur L'analyse du code assembleur généré est nécessaire pour inspecter la réussite ou non de l'opération.</p>
</li>
<li>
<p>Une troisième voie consiste à explorer le partitionnement temporel du calcul, ou <em>time tiling</em>, et notamment les méthodes appelées <em>overlapped tiling</em> ou <em>split tiling</em>. Veuillez vous adresser aux enseignants pour explorer cette optimisation.</p>
</li>
</ol>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./prise_en_main.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./ressources.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./prise_en_main.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./ressources.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
