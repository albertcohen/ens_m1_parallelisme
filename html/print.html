<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Sujets des TDs du cours de programmation parallèle et réactive</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Sujets de TDs pour le cours de M1 sur la programmation parallèle et réactive à l'ENS">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./td_1.html"><strong>1.</strong> TD 1 - Parallelisme de données</a></li><li><ul class="section"><li><a href="./prise_en_main.html"><strong>1.1.</strong> Prise en main de Rust</a></li><li><a href="./chaleur.html"><strong>1.2.</strong> Propagation de la chaleur</a></li></ul></li><li><a href="./ressources.html"><strong>2.</strong> Ressources utiles</a></li><li><ul class="section"><li><a href="benchmark.html"><strong>2.1.</strong> Benchmark de code Rust</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Sujets des TDs du cours de programmation parallèle et réactive</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#td-1---initiation-à-rust" id="td-1---initiation-à-rust"><h1>TD 1 - Initiation à Rust</h1></a>
<p>Le but de ce TD est de se familiariser avec Rust et de démontrer l'utilité du parallélisme
de données en parallélisant une simulation de la diffusion de la chaleur en 2D.</p>
<p>Si ce n'est pas déjà fait, nous vous demandons de faire le tutoriel d'introduction et de
prendre connaissance des différentes constructions disponibles présentées dans le <a href="https://doc.rust-lang.org/book/second-edition/">rust
book</a>. En cas de difficultés, nous avons listé des ressources utiles pour
coder en Rust sur <a href="ressources.html">cette page</a>. Vous pouvez ensuite passer à l'Exercice
1.1.</p>
<a class="header" href="print.html#prise-en-main-de-rust" id="prise-en-main-de-rust"><h1>Prise en main de Rust</h1></a>
<p>Cette exercice a pour but de vérifier que vous savez utiliser les constructions de base en
Rust. En cas de difficulté, il est conseillé de vous référer à la <a href="ressources.html">page</a>
recensant les ressources disponibles pour apprendre et utiliser Rust.</p>
<p><strong>Question 1.</strong> Créez un fonction <code>gen_array</code> qui prend en argument un entier N et renvoie
un tableau contenant les entiers de 0 à N-1.</p>
<p>Afin de vérifier que votre code est correct, nous allons utiliser les fonctionnalités de
test de Rust. Pour ajouter un test à votre code il suffit de créer une fonction sans
arguments précédé de l'attribut <code>#[test]</code>. Vous pouvez ensuite lancer tous les tests avec
la commande <code>cargo test</code>. Par exemple, vous pouvez utiliser la fonction ci-dessous pour
tester <code>gen_array</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn test_gen_array() {
  assert_eq!(gen_array(5), vec![0, 1, 2, 3, 4]);
}
#}</code></pre></pre>
<p><strong>Question 2.</strong> Écrire une fonction <code>partial_sums</code> qui prend en argument une référence
mutable vers un tableau et qui remplace chaque case de tableau par la somme partielle des
valeurs la précédent (valeur remplacée incluse).</p>
<p>Vous testerez votre fonction avec le code ci-dessous.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn test_partial_sums() {
    let mut array = vec![1, 2, 3, 4, 5];
    partial_sums(&amp;mut array);
    assert_eq!(array, vec![1, 3, 6, 10, 15]);
}
#}</code></pre></pre>
<a class="header" href="print.html#simulation-de-la-propagation-de-la-chaleur" id="simulation-de-la-propagation-de-la-chaleur"><h1>Simulation de la propagation de la chaleur</h1></a>
<p>Le but de cet exercice est de simuler la propagation de la chaleur dans un matériau
uniforme, en deux dimensions. Pour cela, on commencera par écrire une version séquentielle
du calcul avant de le paralléliser.</p>
<a class="header" href="print.html#affichage-de-la-carte-de-température" id="affichage-de-la-carte-de-température"><h2>Affichage de la carte de température</h2></a>
<p>La première étape est de créer un projet qui affiche un image dans un fenêtre. Pour cela,
nous utiliserons les bibliothèques:</p>
<ul>
<li><a href="https://crates.io/crates/piston_window">piston_window</a> pour afficher une fenêtre graphique,</li>
<li><a href="https://crates.io/crates/image">image</a> pour créer une image à partir de la distribution de la température,
et</li>
<li><a href="https://crates.is/crates/fps_counter">fps_counter</a> pour compter le nombre d'images produites par seconde.</li>
</ul>
<p>Créez un nouveau projet Rust (<code>cargo init --bin</code>) et éditez la section <code>[dependencies]</code> du
ficher <code>Cargo.toml</code> pour dépendre de ces libraires.</p>
<pre><code class="language-toml">[dependencies]
fps_counter = &quot;1.0&quot;
image = &quot;0.15&quot;
piston_window = &quot;0.70&quot;
</code></pre>
<p>On donne une fonction <code>display</code> qui affiche une image dans une fenêtre. Cette fonction
prend en argument le titre de la fenêtre, sa largeur et sa hauteur ainsi qu'une fonction
<code>step</code> calculant un pas de la simulation. La fonction <code>step</code> prend en argument une
référence mutable vers l'image afficher dans la fenêtre et est chargée de la mettre à
jours pour le pas suivant.</p>
<pre><pre class="playpen"><code class="language-rust">//! Simulation de l'équation de la chaleur.
extern crate fps_counter;
extern crate image;
extern crate piston_window;

use piston_window::*;

/// Ouvre une fenêtre pour afficher une image. L'image est mise à jour entre chaque
/// affichage en appelant la fonction `step`.
pub fn display&lt;F&gt;(title: &amp;str, height: usize, width: usize, mut step: F)
        where F: FnMut(&amp;mut image::RgbaImage) {
    // Création de la fenêtre.
    let glutin_window = WindowSettings::new(title, (width as u32, height as u32))
        .exit_on_esc(true)
        .resizable(false)
        .srgb(false) // Necessary due to issue #139 of piston_window.
        .build()
        .unwrap_or_else(|e| panic!(&quot;Failed to build window: {}&quot;, e));
    let mut window: PistonWindow = PistonWindow::new(OpenGL::V3_2, 0, glutin_window);
    // Création de l'image.
    let black_pixel = image::Rgba { data: [0, 0, 0, 255] };
    let mut img = image::RgbaImage::from_pixel(width as u32, height as u32, black_pixel);
    let tex_settings = TextureSettings::new();
    let mut tex_factory = window.factory.clone();
    // Création du conteur de FPS.
    let mut fps_counter = fps_counter::FPSCounter::new();
    let font = &quot;assets/FiraMono-Regular.ttf&quot;;
    let glyph_settings = TextureSettings::new();
    let mut glyphs = Glyphs::new(font, window.factory.clone(), glyph_settings).unwrap();

    // Boucle de traitement des évenements.
    while let Some(e) = window.next() {
        window.draw_2d(&amp;e, |c, g| {
            clear([0.0, 0.0, 0.0, 1.0], g);
            // Affichage d'un pas de calcul.
            step(&amp;mut img);
            let tex = Texture::from_image(&amp;mut tex_factory, &amp;img, &amp;tex_settings).unwrap();
            image(&amp;tex, c.transform, g);
            // Affichage du compteur de fps.
            let fps = format!(&quot;{} fps&quot;, fps_counter.tick());
            let transform = c.transform.trans((width-100) as f64, 30.0);
            text([1.0, 1.0, 1.0, 1.0], 32, &amp;fps, &amp;mut glyphs, transform, g);
        });
        e.idle(|_| {
            fps_counter.tick();
            step(&amp;mut img);
        });
    }
}

/// Hauteur de la carte de température.
const HEIGHT: usize = 600;
// Largeur de la carte de température.
const WIDTH: usize = 800;

fn main() {
    display(&quot;Propagation de la chaleur 2D&quot;, HEIGHT, WIDTH, |image| {
      // TODO: calculer un pas de simulation
    });
}
</code></pre></pre>
<p>Pour pouvoir afficher le nombre d'image par seconde, nous avons besoin de fournir une
police de caractères. Pour cela, créez un dossier <code>assets/</code> à la racine du projet et
copiez y le fichier de police <a href="https://github.com/mozilla/Fira/raw/master/ttf/FiraMono-Regular.ttf">Fira Mono</a> (<a href="https://raw.githubusercontent.com/mozilla/Fira/master/LICENSE">license</a>).</p>
<p>Si vous compiler et exécutez le code, vous devriez maintenant voir une fenêtre noire avec
un compteur d'image par seconde en haut à droite s'afficher. Le deuxième étape est
maintenant de mettre à jours l'image avec la valeur de la température. La température est
stockée dans un tableau de tableau de flotants (type <code>Vec&lt;Vec&lt;f64&gt;&gt;</code>). Afin de convertir
la température en couleur, nous fournissons la fonctions <code>map_color</code> qui convertie un
flotant entre -1 et 1 en composantes rouge, verte et bleue.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Maps values between -1 and 1 to RGB colors.
fn map_color(value: f64) -&gt; (u8, u8, u8) {
    // Express as HSL with S=1 and L=.5, and H between 0(red) and 4/6(blue).
    let h = f64::max(0.0, f64::min(1.0, (1.0-value) * 2.0/6.0));
    // Then convert to RGB.
    let x = 1.0 - (((h*6.0) % 2.0) - 1.0).abs();
    let (r, g, b) = if h &lt; 1.0/6.0 {
        (1.0, x, 0.0)
    } else if h &lt; 2.0/6.0 {
        (x, 1.0, 0.0)
    } else if h &lt; 3.0/6.0 {
        (0.0, 1.0, x)
    } else {
        (0.0, x, 1.0)
    };
    ((r*255.0) as u8, (g*255.0) as u8 , (b*255.0) as u8)
}
#}</code></pre></pre>
<p><strong>Question 1.</strong> Écrivez une fonction <code>temp_to_image</code> qui prend en entrée une référence
vers la matrice de température et une référence mutable vers l'image et qui modifie
l'image pour représenter la température. L'image est représentée comme un tableau de bytes
(type <code>[u8]</code>) de taille <code>4*HEIGHT*WIDTH</code> où:</p>
<ul>
<li>la case <code>4 * (i * WIDTH + j)</code> représente la composante rouge du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 1</code> représente la composante verte du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 2</code> représente la composante bleue du pixel (i, j).</li>
<li>la case <code>4 * (i * WIDTH + j) + 3</code> représente la composante transparence du pixel (i, j),
à laisser à 255 (opaque) dans notre cas.</li>
</ul>
<p><strong>Question 2.</strong> Pour vérifier que tout marche, on va maintenant afficher la distribution
de température \(u(x, y, t)\):</p>
<p>\[u(x, y, t) = \sin \left( \frac{t+x+y}{2\pi} \right)\]</p>
<p>Modifiez la fonction <code>main</code> pour afficher cette distribution en utilisant la fonction
<code>temp_to_image</code>. Vous utiliserez les constantes <code>DT</code> et <code>DX</code> définies comme suit pour
représenter le pas temporel de calcul et l'espacement entre deux pixels. La constante
\(\pi\) est définie en Rust par <code>std::f64::consts::PI</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Pas temporel de calcul.
const DT: f64 = 1.0e-2;
/// Pas dimentionel de calcul.
const DX: f64 = 1.0e-1;
#}</code></pre></pre>
<p>Vous devriez obtenir une image avec des bandes transversales qui se déplacent, comme dans
l'image ci-dessous.</p>
<p><img src="img/heat_wave.jpg" alt="Vagues de chaleur" /></p>
<a class="header" href="print.html#calcul-séquentiel" id="calcul-séquentiel"><h2>Calcul séquentiel</h2></a>
<p>On va maintenant passer à la simulation de la diffusion de la chaleur. La propagation de
la chaleur est définie par l'équation:
\[\frac{\partial u}{\partial t} =
K \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right)
\]
Ce qui donne, une fois discrétisé:
\[
\begin{eqnarray}
u(t+dt, x, y) = u(t, x, y) + \frac{K \times dt}{dx^2} &amp;\Big[&amp; u(t, x-dx, y) + u(t, x+dx, y) - 2 u(t, x, y) \\
&amp;+&amp; u(t, x, y-dx) + u(t, x, y+dx) - 2 u(t, x, y) \Big]
\end{eqnarray}
\]</p>
<p><strong>Question 3.</strong> Écrire une fonction <code>small_step</code> qui calcule la nouvelle carte de
température en fonction de l'ancienne. La constante <code>K</code> sera pour le moment fixée à 25.
On réutilisera la distribution de la question 2 pour la valeur de la température aux
bords.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const K: f64 = 25.0;

fn small_step(old_temp: &amp;Vec&lt;Vec&lt;f64&gt;&gt;, new_temp: &amp;mut Vec&lt;Vec&lt;f64&gt;&gt;, time: f64) {
    // TODO: calculer new_temp en fonction de old_temp
}
#}</code></pre></pre>
<p>On ne peux pas afficher la carte de température à chaque pas de calcul car cela
consommerait trop de ressources. À la place, on fait plusieurs appels à <code>small_step</code> dans
chaque appel de la fonction <code>step</code> passée à display. Le nombre de petits pas de calcul
sera défini par la constante <code>SMALL_STEP</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const SMALL_STEP: usize = 32;
#}</code></pre></pre>
<p><strong>Question 4.</strong> Modifiez la fonction <code>main</code> pour simulez l'équation de la chaleur. On
initialisera la carte de température à <code>-1</code>. Pour échanger les valeurs de l'ancienne de la
nouvelle carte de température, vous pourrez utiliser la fonction
<a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>std::mem::swap</code></a></p>
<p>Il est conseillé de fixer <code>DT</code> à \(10^{-4}\) pour que le pas temporel ne soit pas trop
grand et que la simulation fonctionne. Vous pourrez ensuite jouer avec les différents
paramètre pour voire comment évolue la distribution de la chaleur.</p>
<p>Attention, si vous voulez tester la rapidité de votre code, il faut passer l'option
<code>--release</code> à Cargo. En effet, sans cette option, le code généré sera beaucoup moins
optimisé et donc anormalement lent.</p>
<a class="header" href="print.html#parallélisation-du-code" id="parallélisation-du-code"><h2>Parallélisation du code</h2></a>
<p>On va maintenant paralléliser les fonctions <code>small_step</code> et <code>temp_to_image</code> afin
d'accélérer la simulation. Pour cela, nous utiliserons la bibliothèque <a href="https://crates.io/crates/rayon">rayon</a>
vue en cours.  Il faut donc ajouter une dépendance à la version <code>0.8</code> de rayon dans le
fichier <code>Cargo.toml</code>. Nous vous invitons fortement à consulter la
<a href="https://docs.rs/rayon/">documentation</a> de rayon et notamment les pages sur les traits
<a href="https://docs.rs/rayon/0.8.2/rayon/iter/trait.ParallelIterator.html">ParallelIterator</a> et <a href="https://docs.rs/rayon/0.8.2/rayon/iter/trait.IndexedParallelIterator.html">IndexedParallelIterator</a>
qui indiquent les opérations que l'on peux effectuer sur un itérateur parallèle et sur un
itérateur parallèle indexé. On rappelle que pour utiliser rayon, il faut importer le
prélude de rayon dans le contexte:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rayon::prelude::*;
#}</code></pre></pre>
<p><strong>Question 5.</strong> Écrivez un version parallèle de <code>small_step</code> que vous nommerez
<code>small_step_par</code> et modifiez la fonction <code>main</code> pour l'utiliser. Vérifiez que vous
améliorez bien la vitesse de simulation.</p>
<p><strong>Question 6.</strong> De même, parallélisez la fonction <code>temp_to_image</code> dans une nouvelle
fonction <code>temp_to_image_par</code>.</p>
<p>On veux maintenant mesurer de façon précise le gain de performance apporté par le
parallélisme. Pour cela, on va benchmarker la fonction <code>small_step</code> en isolation.
Pour mesurer le temps d'exécution, on utilisera les fonctionnalités de benchmarking de
Rust décrites <a href="benchmark.html">ici</a>.</p>
<p><strong>Question 7.</strong> Calculez le facteur d'accélération des versions parallèles de
<code>small_step</code> et de <code>temp_to_image</code> par rapport aux versions séquentielles.</p>
<p><strong>Question 8 (exploratoire).</strong> On souhaite à présent optimiser la fonction <code>small_step</code> afin
d'accélérer encore la simulation.</p>
<ol>
<li>
<p>La première idée consiste à tirer parti de la localité temporelle du calcul, en effectuant un <em>déroulage de boucle</em> selon la deuxième dimension. Le compilateur pourra ainsi découvrir automatiquement que les valeurs lues sur le front droit du stencil viennent d'être calculées quelques instructions plus tôt, et éliminera ainsi quelques accès mémoire.</p>
</li>
<li>
<p>Une autre approche repose sur la <em>vectorisation</em> des instructions de calcul à travers plusieurs itérations de la première dimension. Le compilateur Rust reposant sur LLVM (http://llvm.org), un environnement très riche de compilation disposant d'une passe de vectorisation automatique, capable de regrouper plusieurs opérations ou accès mémoire consécutifs en une seule instruction dite <em>vectorielle</em> (ou <em>SIMD</em>) du processeur. On pourra tenter de déclencher cette vectorisation au prix d'une transformation de boucles appelée <em>stripmining</em>, effectuant le calcul par pas d'exactement 4 itérations (les instructions vectorielles sur processeurs x86 sont de taille 256 bits, soit 4 nombres à virgule flottante de 64 bits sur la plupart des processeurs récents). La configuration fine du compilateur L'analyse du code assembleur généré est nécessaire pour inspecter la réussite ou non de l'opération.</p>
</li>
<li>
<p>Une troisième voie consiste à explorer le partitionnement temporel du calcul, ou <em>time tiling</em>, et notamment les méthodes appelées <em>overlapped tiling</em> ou <em>split tiling</em>. Veuillez vous adresser aux enseignants pour explorer cette optimisation.</p>
</li>
</ol>
<a class="header" href="print.html#ressources-utiles" id="ressources-utiles"><h1>Ressources utiles</h1></a>
<a class="header" href="print.html#installer-rust" id="installer-rust"><h2>Installer Rust</h2></a>
<p>Pour installer Rust, il faut se rendre sur le <a href="https://www.rust-lang.org">site du langage</a> et suivre les
instructions. Dans le cas où préféreriez utiliser votre gestionnaire de paquets,
assurez-vous que <code>cargo</code>, le gestionnaire de dépendances de Rust, soit aussi installé.</p>
<a class="header" href="print.html#programmer-en-rust" id="programmer-en-rust"><h2>Programmer en Rust</h2></a>
<p>Le <a href="https://doc.rust-lang.org/book/second-edition/">Rust Book</a> est la source d'information la plus complète concernant Rust. En
plus d'une description détaillée des fonctionnalités du langage, il propose un tutoriel
très basique pour prendre en main Rust et les outils associés.  Plus concis, <a href="https://rustbyexample.com/">Rust by
Example</a> explique les constructions du langage et les fonctions de la
bibliothèque standard sous forme d'exemples. Il est conseillé de commencer avec le Rust Book,
puis de piocher entre le deux sites selon vos préférences.</p>
<p>Rust est fourni avec une bibliothèque standard dont la documentation est disponible
<a href="http://docs.rs/std">ici</a>. Celle-ci fournit de nombre types, objets et fonctions de base, comme
les tableaux, les tables de hachage, les opérations d'entrée/sortie ou la manipulation des
chaînes de caractères pour n'en citer que quelques uns.</p>
<a class="header" href="print.html#utiliser-le-gestionnaire-de-dépendances" id="utiliser-le-gestionnaire-de-dépendances"><h2>Utiliser le gestionnaire de dépendances</h2></a>
<p>Plutôt que d'utiliser le compilateur Rust - <code>rustc</code> - pour compiler votre code, il est
préférable d'utiliser <code>cargo</code>. Cet outil se charge de télécharger les dépendances, de
compiler les fichiers dans le bon ordre et de gérer les différentes options de
compilation. La documentation de cargo est disponible <a href="http://doc.crates.io/guide.html">ici</a>.</p>
<p>Les commandes a connaître sont:</p>
<ul>
<li><code>cargo init --bin</code> pour initialiser un projet Rust géré par Cargo.</li>
<li><code>cargo build</code> et <code>cargo build --release</code> pour compiler le projet, en mode debug (sans
optimisations dans le code généré) ou release (avec optimisations, mais plus lent à
compiler). L'exécutable généré se trouve dans <code>target/debug/</code> ou <code>target/release/</code>.</li>
<li><code>cargo run</code> et <code>cargo run --release</code> pour compiler et exécuter le code.</li>
</ul>
<p>Les bibliothèques produites par la communauté Rust sont publiées sur le site
<a href="https://crates.io">crates.io</a>. Ce site fourni des options de recherche pour trouver les bibliothèques
répondant à vos besoins. Une fois une bibliothèque trouvée, vous pouvez l'ajouter comme
dépendance de votre projet en modifiant le fichier <code>Cargo.toml</code> à la racine de votre
projet. Par exemple, pour utiliser la version <code>0.8</code> de la bibliothèque <code>rayon</code>, il faut
ajouter la ligne:</p>
<pre><code>rayon = &quot;0.8&quot;
</code></pre>
<p>dans la section <code>[dependencies]</code> de votre fichier <code>Cargo.toml</code>.</p>
<p>Vous pouvez accéder à la documentation de chaque bibliothèque sur le site <a href="http://docs.rs">docs.rs</a>.</p>
<a class="header" href="print.html#Écrire-un-benchmark" id="Écrire-un-benchmark"><h1>Écrire un benchmark</h1></a>
<p>Le plus simple pour écrire un benchmark en Rust est d'utiliser la librairie <code>rustc-test</code>
qui est intégrée avec le compilateur Rust et Cargo. Pour cela, il faut commencer par
ajouter une dépendance à rustc-test dans le ficher `Cargo.toml.</p>
<pre><code class="language-toml">rustc-test = &quot;0.2&quot;
</code></pre>
<p>On peux ensuite écrire un benchmark en créant une fonction précédée de l'attribut
<code>[bench]</code> qui prend en argument une référence mutable vers un <code>Bencher</code>, comme dans
l'exemple ci-dessous. Le code à évaluer doit être donné en argument à la méthode
<code>Bencher::iter</code>. Cette méthode exécute plusieurs fois la clôture donnée en argument et
affiche le temps d'exécution moyen dans la console.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate test;

use test::Bencher;

/// Adds two vectors
fn add_vec(lhs: &amp;Vec&lt;u32&gt;, rhs: &amp;Vec&lt;u32&gt;) -&gt; Vec&lt;u32&gt; {
  lhs.iter().zip(rhs).map(|(lhs, rhs)| lhs+rhs).collect()
}

/// A benchmark for the `add_vec` function.
#[bench]
fn bench_add_vec(bencher: &amp;mut Bencher) {
    // Initialize the benchmark data.
    let input_lhs = vec![1, 2, 3, 4, 5];
    let input_rhs = vec![5, 4, 3, 2, 1];
    // Let the bencher compute the average execution time.
    bencher.iter(|| add_vec(&amp;input_lhs, &amp;input_rhs));
}
#}</code></pre></pre>
<p>Pour compiler et exécuter tous les benchmarks, il suffit de lancer la commande <code>cargo bench</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
